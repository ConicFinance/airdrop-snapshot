import argparse
import gzip
import json
import os
from decimal import Decimal
from os import path
from typing import Optional

from tqdm import tqdm
from web3 import HTTPProvider, Web3
from web3.contract import Contract


INITIAL_DISTRIBUTION_SNAPSHOT_BLOCK = 14_528_680
BOOST_AIRDROP_SNAPSHOT_BLOCK = 16_721_668
CUT_OFF = Decimal(100) * 10**18

VECRV_DEPLOYED_BLOCK = 10_647_812
VECRV_ADDRESS = Web3.toChecksumAddress("0x5F3B5DFEB7B28CDBD7FABA78963EE202A494E2A2")


parser = argparse.ArgumentParser(prog="vecrv")
parser.add_argument(
    "-t",
    "--type",
    choices=["initial-distribution", "airdrop-boost"],
    help="Type of the current event",
    required=True,
)

subparsers = parser.add_subparsers(dest="command")

fetch_addresses_parser = subparsers.add_parser(
    "fetch-addresses", help="Fetch all veCRV holders ever"
)
fetch_addresses_parser.add_argument("-o", "--output", help="Output file", required=True)

fetch_balances_parser = subparsers.add_parser(
    "fetch-balances", help="Fetch balances of veCRV holders at snapshot block"
)
fetch_balances_parser.add_argument(
    "inputs", nargs="+", help="Input file(s) generated by fetch-addresses"
)
fetch_balances_parser.add_argument("-o", "--output", help="Output file", required=True)


def get_w3():
    return Web3(HTTPProvider(os.environ["ETH_RPC_URL"]))


def get_vecrv(w3: Optional[Web3] = None) -> Contract:
    if w3 is None:
        w3 = get_w3()
    with open(
        path.join(path.dirname(path.dirname(__file__)), "abis", "vecrv.abi.json")
    ) as f:
        abi = json.load(f)
    return w3.eth.contract(address=VECRV_ADDRESS, abi=abi)


def get_start_block(event_type):
    if event_type == "initial-distribution":
        return VECRV_DEPLOYED_BLOCK
    elif event_type == "airdrop-boost":
        return INITIAL_DISTRIBUTION_SNAPSHOT_BLOCK + 1
    else:
        raise ValueError(f"Unknown event type: {event_type}")


def get_snapshot_block(event_type):
    if event_type == "initial-distribution":
        return INITIAL_DISTRIBUTION_SNAPSHOT_BLOCK
    elif event_type == "airdrop-boost":
        return BOOST_AIRDROP_SNAPSHOT_BLOCK
    else:
        raise ValueError(f"Unknown event type: {event_type}")


def _fetch_addresses(ve_crv, start_block, end_block, chunk_size=10_000):
    unique_accounts = set()
    for block in tqdm(range(start_block, end_block, chunk_size)):
        to_block = min(block + chunk_size, end_block)
        entries = ve_crv.events.Deposit.getLogs(fromBlock=block, toBlock=to_block)
        unique_accounts.update(e["args"]["provider"] for e in entries)
    return unique_accounts


def fetch_addresses(args):
    ve_crv = get_vecrv()

    start_block = get_start_block(args.type)
    end_block = get_snapshot_block(args.type)
    unique_addresses = _fetch_addresses(ve_crv, start_block, end_block)

    with gzip.open(args.output, "wt") as f:
        for account in unique_addresses:
            print(account, file=f)

    print(f"found {len(unique_addresses)} unique addresses")


def fetch_balances(args):
    w3 = get_w3()
    locker = get_vecrv(w3)

    addresses = set()
    for input_file in args.inputs:
        with gzip.open(input_file, "rt") as f:
            addresses |= {line.strip() for line in f}

    snapshot_block = get_snapshot_block(args.type)

    balances = []
    eoa_count = 0
    for address in tqdm(addresses):
        balance = locker.functions.balanceOf(address).call(
            block_identifier=snapshot_block
        )
        if args.type == "initial-distribution" and balance < CUT_OFF:
            continue
        is_eoa = len(w3.eth.get_code(address)) == 0
        eoa_count += is_eoa
        balances.append({"address": address, "balance": str(balance), "is_eoa": is_eoa})

    with gzip.open(args.output, "wt") as f:
        json.dump(balances, f)

    print(f"found {len(balances)} eligible accounts")


def main():
    args = parser.parse_args()
    if args.command == "fetch-addresses":
        fetch_addresses(args)
    elif args.command == "fetch-balances":
        fetch_balances(args)
    else:
        parser.error("no command given")


if __name__ == "__main__":
    main()
