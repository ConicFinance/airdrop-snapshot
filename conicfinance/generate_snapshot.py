import argparse
import gzip
import json
import os
from decimal import Decimal
from os import path
from typing import Optional

from tqdm import tqdm
from web3 import HTTPProvider, Web3
from web3.contract import Contract

# snapshot at the time of our announcement Tweet
SNAPSHOT_BLOCK = 14_494_800

CVX_LOCKER_ADDRESS = Web3.toChecksumAddress(
    "0x72a19342e8F1838460eBFCCEf09F6585e32db86E"
)
CVX_LOCKER_DEPLOYED_BLOCK = 14_320_609

OLD_CVX_LOCKER_ADDRESS = Web3.toChecksumAddress(
    "0xD18140b4B819b895A3dba5442F959fA44994AF50"
)
OLD_CVX_LOCKER_DEPLOYED_BLOCK = 13_153_663

CVX_CUTOFF = Decimal(3)

TOTAL_SUPPLY = 10_000_000
TOKENS_TO_DISTRIBUTE = TOTAL_SUPPLY // 10  # 10% to vlCVX holders


parser = argparse.ArgumentParser(prog="generate-snapshot")

subparsers = parser.add_subparsers(dest="command")

fetch_addresses_parser = subparsers.add_parser(
    "fetch-addresses", help="Fetch all vlCVX holders ever"
)
fetch_addresses_parser.add_argument("-o", "--output", help="Output file", required=True)

fetch_balances_parser = subparsers.add_parser(
    "fetch-balances", help="Fetch balances of vlCVX holders at snapshot block"
)
fetch_balances_parser.add_argument(
    "input", help="Input file generated by fetch-addresses"
)
fetch_balances_parser.add_argument("-o", "--output", help="Output file", required=True)

generate_snapshot_parser = subparsers.add_parser(
    "generate-snapshot", help="Generate the airdrop snapshot"
)
generate_snapshot_parser.add_argument(
    "input", help="Input file generated by fetch-balances"
)
generate_snapshot_parser.add_argument(
    "-o", "--output", help="Output file", required=True
)


def get_w3():
    return Web3(HTTPProvider(os.environ["ETH_RPC_URL"]))


def get_cvx_locker(w3: Optional[Web3] = None, old: bool = False) -> Contract:
    if w3 is None:
        w3 = get_w3()
    if old:
        file_name, address = "old-cvx-locker.abi.json", OLD_CVX_LOCKER_ADDRESS
    else:
        file_name, address = "cvx-locker.abi.json", CVX_LOCKER_ADDRESS

    with open(path.join(path.dirname(__file__), "abis", file_name)) as f:
        abi = json.load(f)
    return w3.eth.contract(address=address, abi=abi)


def _fetch_addresses(locker, start_block, chunk_size=10_000):
    unique_accounts = set()
    for block in tqdm(range(start_block, SNAPSHOT_BLOCK, chunk_size)):
        end_block = min(block + chunk_size, SNAPSHOT_BLOCK)
        entries = locker.events.Staked.getLogs(fromBlock=block, toBlock=end_block)
        unique_accounts.update(e["args"]["_user"] for e in entries)
    return unique_accounts


def fetch_addresses(args):
    locker = get_cvx_locker()
    old_locker = get_cvx_locker(old=True)

    unique_addresses = _fetch_addresses(locker, CVX_LOCKER_DEPLOYED_BLOCK)
    unique_addresses.update(_fetch_addresses(old_locker, OLD_CVX_LOCKER_DEPLOYED_BLOCK))

    with gzip.open(args.output, "wt") as f:
        for account in unique_addresses:
            print(account, file=f)

    print(f"found {len(unique_addresses)} unique addresses")


def fetch_balances(args):
    w3 = get_w3()
    locker = get_cvx_locker(w3)
    old_locker = get_cvx_locker(w3, old=True)

    with gzip.open(args.input, "rt") as f:
        addresses = [line.strip() for line in f]

    balances = []
    eoa_count = 0
    for address in tqdm(addresses):
        balance = locker.functions.balanceOf(address).call(
            block_identifier=SNAPSHOT_BLOCK
        )
        old_balance = old_locker.functions.balanceOf(address).call(
            block_identifier=SNAPSHOT_BLOCK
        )
        total_balance = balance + old_balance
        is_eoa = len(w3.eth.get_code(address)) == 0
        eoa_count += is_eoa
        balances.append(
            {"address": address, "balance": str(total_balance), "is_eoa": is_eoa}
        )

    with gzip.open(args.output, "wt") as f:
        json.dump(balances, f)

    print(f"found {eoa_count} EOAs")


def generate_snapshot(args):
    with gzip.open(args.input) as f:
        accounts = json.load(f)

    for account in accounts:
        account["balance"] = Decimal(account["balance"]) / 10**18

    eligible_accounts = [
        account for account in accounts if account["balance"] >= CVX_CUTOFF
    ]

    log_balances = [account["balance"].ln() for account in eligible_accounts]
    total_log_cvx = sum(log_balances)

    airdrop = []
    total_value = 0
    for i, account in enumerate(eligible_accounts):
        value = log_balances[i] * TOKENS_TO_DISTRIBUTE / total_log_cvx
        scaled_value = int(value * 10**18)
        total_value += scaled_value
        airdrop.append(
            {
                "address": account["address"],
                "value": str(scaled_value),
            }
        )

    with open(args.output, "w") as f:
        json.dump(airdrop, f, indent=2)

    print(f"total value: {total_value / 1e18}")


def main():
    args = parser.parse_args()
    if args.command == "fetch-addresses":
        fetch_addresses(args)
    elif args.command == "fetch-balances":
        fetch_balances(args)
    elif args.command == "generate-snapshot":
        generate_snapshot(args)
    else:
        parser.error("no command given")


if __name__ == "__main__":
    main()
