import argparse
import gzip
import json
import os
from decimal import Decimal
from os import path
from typing import Optional

from tqdm import tqdm
from web3 import HTTPProvider, Web3
from web3.contract import Contract


SNAPSHOT_BLOCK = 14_528_680
CUT_OFF = Decimal(100) * 10**18

VECRV_DEPLOYMED_BLOCK = 10_647_812
VECRV_ADDRESS = Web3.toChecksumAddress("0x5F3B5DFEB7B28CDBD7FABA78963EE202A494E2A2")


parser = argparse.ArgumentParser(prog="generate-whitelist")

subparsers = parser.add_subparsers(dest="command")

fetch_addresses_parser = subparsers.add_parser(
    "fetch-addresses", help="Fetch all veCRV holders ever"
)
fetch_addresses_parser.add_argument("-o", "--output", help="Output file", required=True)

generate_whitelist_parser = subparsers.add_parser(
    "generate-whitelist", help="Generate whitelist of veCRV holders at snapshot block"
)
generate_whitelist_parser.add_argument(
    "input", help="Input file generated by fetch-addresses"
)
generate_whitelist_parser.add_argument(
    "-o", "--output", help="Output file", required=True
)


def get_w3():
    return Web3(HTTPProvider(os.environ["ETH_RPC_URL"]))


def get_vecrv(w3: Optional[Web3] = None) -> Contract:
    if w3 is None:
        w3 = get_w3()
    with open(path.join(path.dirname(__file__), "abis", "vecrv.abi.json")) as f:
        abi = json.load(f)
    return w3.eth.contract(address=VECRV_ADDRESS, abi=abi)


def _fetch_addresses(ve_crv, start_block, chunk_size=10_000):
    unique_accounts = set()
    for block in tqdm(range(start_block, SNAPSHOT_BLOCK, chunk_size)):
        end_block = min(block + chunk_size, SNAPSHOT_BLOCK)
        entries = ve_crv.events.Deposit.getLogs(fromBlock=block, toBlock=end_block)
        unique_accounts.update(e["args"]["provider"] for e in entries)
    return unique_accounts


def fetch_addresses(args):
    ve_crv = get_vecrv()

    unique_addresses = _fetch_addresses(ve_crv, VECRV_DEPLOYMED_BLOCK)

    with gzip.open(args.output, "wt") as f:
        for account in unique_addresses:
            print(account, file=f)

    print(f"found {len(unique_addresses)} unique addresses")


def generate_whitelist(args):
    w3 = get_w3()
    locker = get_vecrv(w3)

    with gzip.open(args.input, "rt") as f:
        addresses = [line.strip() for line in f]

    balances = []
    eoa_count = 0
    for address in tqdm(addresses):
        balance = locker.functions.balanceOf(address).call(
            block_identifier=SNAPSHOT_BLOCK
        )
        if balance < CUT_OFF:
            continue
        is_eoa = len(w3.eth.get_code(address)) == 0
        eoa_count += is_eoa
        balances.append({"address": address, "balance": str(balance), "is_eoa": is_eoa})

    with gzip.open(args.output, "wt") as f:
        json.dump(balances, f)

    print(f"found {len(balances)} eligible accounts")


def main():
    args = parser.parse_args()
    if args.command == "fetch-addresses":
        fetch_addresses(args)
    elif args.command == "generate-whitelist":
        generate_whitelist(args)
    else:
        parser.error("no command given")


if __name__ == "__main__":
    main()
